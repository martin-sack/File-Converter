module.exports = [
"[project]/node_modules/@ffmpeg/util/dist/esm/errors.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ERROR_INCOMPLETED_DOWNLOAD",
    ()=>ERROR_INCOMPLETED_DOWNLOAD,
    "ERROR_RESPONSE_BODY_READER",
    ()=>ERROR_RESPONSE_BODY_READER
]);
const ERROR_RESPONSE_BODY_READER = new Error("failed to get response body reader");
const ERROR_INCOMPLETED_DOWNLOAD = new Error("failed to complete download");
}),
"[project]/node_modules/@ffmpeg/util/dist/esm/const.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "HeaderContentLength",
    ()=>HeaderContentLength
]);
const HeaderContentLength = "Content-Length";
}),
"[project]/node_modules/@ffmpeg/util/dist/esm/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "downloadWithProgress",
    ()=>downloadWithProgress,
    "fetchFile",
    ()=>fetchFile,
    "importScript",
    ()=>importScript,
    "toBlobURL",
    ()=>toBlobURL
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ffmpeg$2f$util$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ffmpeg/util/dist/esm/errors.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ffmpeg$2f$util$2f$dist$2f$esm$2f$const$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ffmpeg/util/dist/esm/const.js [app-ssr] (ecmascript)");
;
;
const readFromBlobOrFile = (blob)=>new Promise((resolve, reject)=>{
        const fileReader = new FileReader();
        fileReader.onload = ()=>{
            const { result } = fileReader;
            if (result instanceof ArrayBuffer) {
                resolve(new Uint8Array(result));
            } else {
                resolve(new Uint8Array());
            }
        };
        fileReader.onerror = (event)=>{
            reject(Error(`File could not be read! Code=${event?.target?.error?.code || -1}`));
        };
        fileReader.readAsArrayBuffer(blob);
    });
const fetchFile = async (file)=>{
    let data;
    if (typeof file === "string") {
        /* From base64 format */ if (/data:_data\/([a-zA-Z]*);base64,([^"]*)/.test(file)) {
            data = atob(file.split(",")[1]).split("").map((c)=>c.charCodeAt(0));
        /* From remote server/URL */ } else {
            data = await (await fetch(file)).arrayBuffer();
        }
    } else if (file instanceof URL) {
        data = await (await fetch(file)).arrayBuffer();
    } else if (file instanceof File || file instanceof Blob) {
        data = await readFromBlobOrFile(file);
    } else {
        return new Uint8Array();
    }
    return new Uint8Array(data);
};
const importScript = async (url)=>new Promise((resolve)=>{
        const script = document.createElement("script");
        const eventHandler = ()=>{
            script.removeEventListener("load", eventHandler);
            resolve();
        };
        script.src = url;
        script.type = "text/javascript";
        script.addEventListener("load", eventHandler);
        document.getElementsByTagName("head")[0].appendChild(script);
    });
const downloadWithProgress = async (url, cb)=>{
    const resp = await fetch(url);
    let buf;
    try {
        // Set total to -1 to indicate that there is not Content-Type Header.
        const total = parseInt(resp.headers.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ffmpeg$2f$util$2f$dist$2f$esm$2f$const$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["HeaderContentLength"]) || "-1");
        const reader = resp.body?.getReader();
        if (!reader) throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ffmpeg$2f$util$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ERROR_RESPONSE_BODY_READER"];
        const chunks = [];
        let received = 0;
        for(;;){
            const { done, value } = await reader.read();
            const delta = value ? value.length : 0;
            if (done) {
                if (total != -1 && total !== received) throw __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ffmpeg$2f$util$2f$dist$2f$esm$2f$errors$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ERROR_INCOMPLETED_DOWNLOAD"];
                cb && cb({
                    url,
                    total,
                    received,
                    delta,
                    done
                });
                break;
            }
            chunks.push(value);
            received += delta;
            cb && cb({
                url,
                total,
                received,
                delta,
                done
            });
        }
        const data = new Uint8Array(received);
        let position = 0;
        for (const chunk of chunks){
            data.set(chunk, position);
            position += chunk.length;
        }
        buf = data.buffer;
    } catch (e) {
        console.log(`failed to send download progress event: `, e);
        // Fetch arrayBuffer directly when it is not possible to get progress.
        buf = await resp.arrayBuffer();
        cb && cb({
            url,
            total: buf.byteLength,
            received: buf.byteLength,
            delta: 0,
            done: true
        });
    }
    return buf;
};
const toBlobURL = async (url, mimeType, progress = false, cb)=>{
    const buf = progress ? await downloadWithProgress(url, cb) : await (await fetch(url)).arrayBuffer();
    const blob = new Blob([
        buf
    ], {
        type: mimeType
    });
    return URL.createObjectURL(blob);
};
}),
];

//# sourceMappingURL=node_modules_%40ffmpeg_util_dist_esm_ca07e6db._.js.map